import asyncio
from services import twitch_pubsub
from services import discord_webhook
import os
import json
import copy
import sys
import datetime

from utils import fileIO
from utils.timer import Timer
from utils import humanReadableTime

class ManagementInterface:

    def __init__(self):
        self.file_path = "commands.txt"
        self.timer = Timer(10, self._check_file)
        #Add commands to dictionary
        self.commands = {}
        self.commands["add_user"] = self._add_user
        self.commands["remove_user"] = self._remove_user
        self.commands["listen"] = self._listen
        self.commands["unlisten"] = self._unlisten
        self.commands["edit_setting"] = self._edit_setting

    async def start_timer(self):
        """Function that starts timer loop"""
        self.timer.start_loop()

    async def _check_file(self):
        """Function to check if file exists and run commands in text file"""
        #Commands file will be generated by management.py
        lines = []
        try: #Try to open file and run command
            with open(self.file_path, "r") as f:
                for line in f: #For all lines (commands) in file
                    lines.append(line)
            os.remove(self.file_path) #Once all commands stored, delete file
            for line in lines: #For every line, extract command and args
                args = line.split()
                command = args.pop(0)
                asyncio.get_event_loop().create_task(self.commands[command](args)) #Call function to handle command
        except FileNotFoundError: #If file not there, don't do anything
            pass
        except KeyError: #If command doesn't exist, don't do anything
            pass

    async def _add_user(self, args):
        """Function to add user to bot and listen on topic"""
        if len(args) >= 3 and args[0] not in bot.users: #if correct amount of arguments supplied
            #Extract information from args
            userid = args[0]
            name = args[1]
            webhook_url = args[2]
            override = {}
            if args[3] == "override": #if overriding user
                override["override_userid"] = args[4]
                override["override_user"] = args[5]
                override["override_oauth"] = args[6]
                blacklist_start = 7
            else:
                blacklist_start = 3
            blacklist = []
            #Try to extrack blacklist, do nothing if no blacklisted users
            try:
                for i in args[blacklist_start:]: #for rest of args
                    blacklist.append(i)
            except IndexError:
                pass
            #Add user to bot
            bot.users[userid] = {}
            bot.users[userid]["name"] = name
            bot.users[userid]["webhook_url"] = webhook_url
            bot.users[userid]["blacklist"] = blacklist
            #Get override info, defaulting to blank string
            bot.users[userid]["override_userid"] = override.get("override_userid", "")
            bot.users[userid]["override_user"] = override.get("override_user", "")
            bot.users[userid]["override_oauth"] = override.get("override_oauth", "")
            #Save JSON file
            fileIO.save_json("users.json", bot.users)
            #Listen to topic on PubSub
            await self._listen([args[0]])

    async def _remove_user(self, args):
        """Function to remove user from bot and unlisten from topic"""
        if len(args) == 1 and args[0] in bot.users: #If correct amount of arguments supplied
            await self._unlisten([args[0]]) #unlisten on PubSub
            bot.users.pop(args[0]) #remove user from system
            fileIO.save_json("users.json", bot.users) #Save JSON file

    async def _edit_user(self, args):
        """Function to edit a setting on a user"""
        if len(args) >= 3 and args[0] in bot.users: #If enough args supplied and user in system
            if args[1] == "blacklist": #If blacklist being modified
                blacklist = [] #Create blacklist
                for i in args[2:]: #For all args pertaining to blacklisted users
                    blacklist.append(i) #Add user to blacklist
                bot.users[args[0]]["blacklist"] = blacklist #Save in users object
            else: #If not blacklist being modified
                bot.users[args[0]][args[1]] = args[2]
            fileIO.save_json("users.json", bot.users) #Save JSON file

    async def _edit_setting(self, args):
        """Function to edit a global setting"""
        if len(args) == 2 and args[0] in bot.settings: #If enough args supplied and setting in system
            bot.settings[args[0]] = args[1]
            fileIO.save_json("settings.json", bot.settings) #Save JSON file

    async def _listen(self, args):
        """Function to create listen object and listen to topic on PubSub"""
        if len(args) == 1 and args[0] in bot.users: #If correct number of args supplied and user exists
            #Create listen object
            listen = bot.create_listen(args[0])
            bot.listens[args[0]] = listen #Add listen to bot listens so it will be retained if bot stopped and started again
            await PubSub.add_listen(listen, args[0])

    async def _unlisten(self, args):
        """Function to create unlisten object and unlisten from topic"""
        if len(args) == 1 and args[0] in bot.listens: #If correct number of args and topic being listened to
            #Unlisten using existing listen object
            await PubSub.remove_listen(bot.listens[args[0]], args[0])
            #Remove listen from dict
            bot.listens.pop(args[0])


class Bot:

    def __init__(self):
        """On initialization of class, assign vars"""
        #Create dict of commands
        self.commands = {}
        self.commands["ban"] = self._ban
        self.commands["unban"] = self._unban
        self.commands["timeout"] = self._timeout
        #Commands to ignore
        self.commands["automod_rejected"] = self._null_function
        self.commands["approved_automod_message"] = self._null_function
        self.commands["denied_automod_message"] = self._null_function
        self.commands["mod"] = self._null_function
        self.commands["unmod"] = self._null_function
        self.commands["host"] = self._null_function
        self.commands["unhost"] = self._null_function
        self.commands["raid"] = self._null_function
        #Load JSON files
        self.users = fileIO.load_json("users.json")
        self.settings = fileIO.load_json("settings.json")
        if self.users == None or self.settings == None: #If either of the two files not found
            sys.exit("Please run management.py and generate users.json and settings.json")
        #Create dict of listens
        self.listens = {}
        #For every user object, create listen object to send to Twitch
        for i in self.users:
            self.listens[i] = self.create_listen(i)

    async def message(self, msg):
        """On message from PubSub, create message to send to Discord"""
        userid = msg["data"]["topic"].split(".")[2]
        oldmsg = msg
        msg = msg["data"]["message"]["data"]
        try: #Debug, trying to trap and figure out the cause of an error
            blacklist_status = msg["created_by"] not in self.users[userid]["blacklist"]
        except KeyError: #If error occurs
            self._generic_error("msg[\"created_by\"] error found:\r\n```json\r\n{0}```".format(json.dumps(oldmsg))) #send message to Discord
        if blacklist_status: #if moderator not blacklisted
            try: #Try to run function to generate message
                discordMessage = self.commands[msg["moderation_action"]](msg, userid)
                webhook_url = self.users[userid]["webhook_url"]
            except KeyError: #If command not supported, send message to error Discord channel
                discordMessage = self._unsupported_action(msg, userid)
                webhook_url = self.settings["error_webhook"]
            #Create JSON object to send to Discord
            messageJson = {}
            messageJson["embeds"] = [discordMessage]
            #Send message
            await WebHook.post_message(webhook_url, messageJson)

    def _ban(self, msg, userid):
        """Generate message for ban command"""
        #Extract information from Twitch message
        bannedUser = msg["args"][0].lstrip("@")
        bannedUserID = msg["target_user_id"]
        moderator = msg["created_by"]
        moderatorID = msg["created_by_user_id"]
        reason = ""
        if msg["args"][1] != "":
            reason = msg["args"][1]
        twitchChannel = self.users[userid]["name"]
        logviewerURL = "http://cbenni.com/{0}/?user={1}".format(twitchChannel, bannedUser)
        #Get timestamp
        timestamp = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()
        #Create embed objects
        author = WebHook.create_author_object(name="Twitch Ban", url=logviewerURL)
        fields = []
        fields.append(WebHook.create_field_object(name="Banned User", value="`{0}`, User ID:`{1}`".format(bannedUser, bannedUserID)))
        fields.append(WebHook.create_field_object(name="Moderator", value="`{0}`, User ID:`{1}`".format(moderator, moderatorID)))
        if reason != "":
            fields.append(WebHook.create_field_object(name="Reason", value="`{0}`".format(reason)))
        #Create embed object and return
        embed = WebHook.create_embed(author=author, fields=fields, color=15019533, timestamp=timestamp)
        return(embed)

    def _unban(self, msg, userid):
        """Generate message for unban command"""
        #Extract information from Twitch message
        unbannedUser = msg["args"][0].lstrip("@")
        unbannedUserID = msg["target_user_id"]
        moderator = msg["created_by"]
        moderatorID = msg["created_by_user_id"]
        twitchChannel = self.users[userid]["name"]
        logviewerURL = "http://cbenni.com/{0}/?user={1}".format(twitchChannel, unbannedUser)
        #Get timestamp
        timestamp = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()
        #Create embed objects
        author = WebHook.create_author_object(name="Twitch Unban", url=logviewerURL)
        fields = []
        fields.append(WebHook.create_field_object(name="Unbanned User", value="`{0}`, User ID:`{1}`".format(unbannedUser, unbannedUserID)))
        fields.append(WebHook.create_field_object(name="Moderator", value="`{0}`, User ID:`{1}`".format(moderator, moderatorID)))
        #Create embed object and return
        embed = WebHook.create_embed(author=author, fields=fields, color=15019533, timestamp=timestamp)
        return(embed)

    def _timeout(self, msg, userid):
        """Generate message for timeout command"""
        #Extract information from Twitch message
        bannedUser = msg["args"][0].lstrip("@")
        bannedUserID = msg["target_user_id"]
        moderator = msg["created_by"]
        moderatorID = msg["created_by_user_id"]
        timeOutTime = int(msg["args"][1])
        timeOutTime = humanReadableTime.time(timeOutTime)
        try:
            reason = msg["args"][2]
        except IndexError:
            reason = ""
        twitchChannel = self.users[userid]["name"]
        logviewerURL = "http://cbenni.com/{0}/?user={1}".format(twitchChannel, bannedUser)
        #Get timestamp
        timestamp = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()
        #Create embed objects
        author = WebHook.create_author_object(name="Twitch Timeout", url=logviewerURL)
        fields = []
        fields.append(WebHook.create_field_object(name="Timed Out User", value="`{0}`, User ID:`{1}`".format(bannedUser, bannedUserID)))
        fields.append(WebHook.create_field_object(name="Time", value="`{0}`".format(timeOutTime)))
        fields.append(WebHook.create_field_object(name="Moderator", value="`{0}`, User ID:`{1}`".format(moderator, moderatorID)))
        if reason != "":
            fields.append(WebHook.create_field_object(name="Reason", value="`{0}`".format(reason)))
        #Create embed object and return
        embed = WebHook.create_embed(author=author, fields=fields, color=15019533, timestamp=timestamp)
        return(embed)

    def _null_function(self, msg, userid):
        """Function for commands that I will not be supporting"""
        pass

    def _unsupported_action(self, msg, userid):
        """Generate Discord message for unsupported mod actions"""
        moderator = msg["created_by"]
        channel = self.users[userid]["name"]
        command = "/{0} {1}".format(msg["moderation_action"], " ".join(msg["args"]) if msg["args"] is not None else '')
        message = "Unsupported command run by {0} in channel {1}: `{2}`".format(moderator, channel, command)
        return(message)

    async def _listen_error(self, error, nonce):
        """Function to create and send message to Discord upon error when listening to topic"""
        listen = copy.deepcopy(self.listens[nonce]) #Store listen in local var (nonce is userid)
        listen["data"].pop("auth_token") #Remove auth token for sending to discord
        #Create message string
        message = "Error `{0}` returned when sending listen:\r\n```json\r\n{1}```".format(error, json.dumps(listen, indent=2))
        #Create JSON object to send to Discord
        messageJson = {}
        messageJson["content"] = message
        #Send message
        await WebHook.post_message(bot.settings["error_webhook"], messageJson)

    async def _generic_error(self, message):
        """Function to send a message directly to twitch for generic error reporting"""
        #Create JSON object to send to Discord
        messageJson = {}
        messageJson["content"] = message
        #Send message
        await WebHook.post_message(bot.settings["error_webhook"], messageJson)

    def create_listen(self, userid):
        listen = {}
        listen["type"] = "LISTEN"
        listen["nonce"] = userid #For error handling in future
        listen["data"] = {}
        #Set user id based on if override or not
        authentication_userid = self.users[userid]["override_userid"] if self.users[userid]["override_userid"] != "" else self.settings["userid"]
        listen["data"]["topics"] = ["chat_moderator_actions.{0}.{1}".format(authentication_userid, userid)]
        listen["data"]["auth_token"] = self.users[userid]["override_oauth"] if self.users[userid]["override_oauth"] != "" else self.settings["oauth"]
        return(listen)
            

if __name__ == "__main__":
    #Initialize classes
    bot = Bot()
    PubSub = twitch_pubsub.PubSub()
    WebHook = discord_webhook.DiscordWebhook()
    Management = ManagementInterface()
    #Run functions
    PubSub.onMsg += bot.message
    PubSub.onListenError += bot._listen_error
    PubSub.onError += bot._generic_error
    asyncio.get_event_loop().create_task(PubSub.connect(bot.listens))
    asyncio.get_event_loop().create_task(Management.start_timer())
    asyncio.get_event_loop().run_forever()